// 1. تعريف المتغيرات الرئيسية
int i = 0;
int x = 0;
int OK = 0; // مفتاح التبديل بين الطرف 9 و 10
const int HALF_WAVE_SAMPLES = 314; // عدد العينات لنصف الموجة الكامل (القيمة الأصلية للمصفوفة)

// ***** المتغير الذي يسمح لك بتعديل فترة التأخير (Dead Time) *****
const int DEAD_TIME_SAMPLES = 16; 
// 16 عينة = حوالي 512 مايكروثانية (بناءً على تردد المقاطعة الحالي)
// لتأخير 100 مايكروثانية، ضع قيمة تقريبية 3 عينات (3 * 32us)
// لتأخير 1000 مايكروثانية (1 مللي ثانية)، ضع قيمة تقريبية 31 عينة (31 * 32us)

// 2. المصفوفة (نحذف منها الأصفار التي أضفناها يدويًا)
int sinPWM[]={1,2,5,7,10,12,15,17,19,22,24,27,30,32,34,37,39,42,
44,47,49,52,54,57,59,61,64,66,69,71,73,76,78,80,83,85,88,90,92,94,97,99,
101,103,106,108,110,113,115,117,119,121,124,126,128,130,132,134,136,138,140,142,144,146,
148,150,152,154,156,158,160,162,164,166,168,169,171,173,175,177,178,180,182,184,185,187,188,190,192,193,
195,196,198,199,201,202,204,205,207,208,209,211,212,213,215,216,217,219,220,221,222,223,224,225,226,227,
228,229,230,231,232,233,234,235,236,237,237,238,239,240,240,241,242,242,243,243,244,244,245,245,246,246,
247,247,247,248,248,248,248,249,249,249,249,249,255,255,255,255,249,249,249,249,249,248,
248,248,248,247,247,247,246,246,245,245,244,244,243,243,242,242,241,240,240,239,238,237,237,236,235,234,
233,232,231,230,229,228,227,226,225,224,223,222,221,220,219,217,216,215,213,212,211,209,208,207,205,204,
202,201,199,198,196,195,193,192,190,188,187,185,184,182,180,178,177,175,173,171,169,168,166,164,162,160,
158,156,154,152,150,148,146,144,142,140,138,136,134,132,130,128,126,124,121,119,117,115,113,110,108,106,
103,101,99,97,94,92,90,88,85,83,80,78,76,73,71,69,66,64,61,59,57,54,52,49,47,44,42,39,37,34,32,30,
27,24,22,19,17,15,12,10,7,5,2,1}; 
// 3. تعريف متغير إضافي للعد خلال فترة التأخير
volatile int deadTimeCounter = 0; // استخدم volatile لأنها تتغير داخل ISR

void setup() {
Serial.begin(9600);
pinMode(9, OUTPUT);
pinMode(10,OUTPUT);
cli();// stop interrupts
TCCR1A=0; TCCR1B=0; TCNT1=0; 
TCCR1A=0b10100001;
TCCR1B=0b00000001; 
TCCR0A=0b1000010;
TCCR0B=0; TCNT0=0;
OCR0A=63;
TCCR0B=0b00000010;
TIMSK0 |=(1 << OCIE0A);
sei();//enable interrupts
}

// 4. دالة معالج المقاطعة المعدلة
ISR(TIMER0_COMPA_vect){

// إذا كان العداد نشطاً، فهذا يعني أننا في فترة التأخير (Dead Time)
if (deadTimeCounter > 0) {
    // نبقي كلا الطرفين مطفأين
    OCR1A = 0;
    OCR1B = 0;
    // إنقاص العداد والانتظار حتى يصبح صفرًا
    deadTimeCounter--;
    // الخروج من الدالة فوراً دون معالجة المصفوفة
    return;
}

// ****** منطق التبديل والتشغيل (يعمل فقط إذا كان deadTimeCounter = 0) ******

// 1. تحقق من نهاية الموجة
if(i >= HALF_WAVE_SAMPLES){ 
    // إذا وصلنا لنهاية الموجة
    i = 0; // إرجاع المؤشر إلى الصفر

    // تفعيل عداد التأخير
    deadTimeCounter = DEAD_TIME_SAMPLES; 

    // تبديل الطرف للعمل بعد انتهاء التأخير
    if (OK == 0) {
        OK = 1; // جهز للطرف 10
    } else {
        OK = 0; // جهز للطرف 9
    }
    return; // الخروج من ISR للبدء في فترة التأخير
}


// 2. تطبيق قيمة PWM (يحدث فقط إذا لم يكن العداد نشطًا ولم نصل للنهاية)
x = sinPWM[i]; // x تأخذ القيمة من المصفوفة
i = i + 1; // الانتقال إلى العينة التالية

if(OK==0){
    OCR1B=0;//make pin 10 0
    OCR1A=x;//enable pin 9 to corresponding duty cycle
} else { // OK==1
    OCR1A=0;//make pin 9 0
    OCR1B=x;//enable pin 10 to corresponding duty cycle
}
}
void loop() {
}
